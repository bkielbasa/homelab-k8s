alloy:
  configMap:
    content: |
      // Discover all Kubernetes pods
      discovery.kubernetes "pods" {
        role = "pod"
      }

      // Relabel pods to add useful labels
      discovery.relabel "pods" {
        targets = discovery.kubernetes.pods.targets

        // Only keep running pods
        rule {
          source_labels = ["__meta_kubernetes_pod_phase"]
          action        = "keep"
          regex         = "Running"
        }

        // Add namespace label
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        // Add pod name label
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        // Add container name label
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        // Add app label if it exists
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app"]
          target_label  = "app"
        }

        // Copy all pod labels
        rule {
          action = "labelmap"
          regex  = "__meta_kubernetes_pod_label_(.+)"
        }

        // Set the log path
        rule {
          source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          separator     = "/"
          target_label  = "__path__"
          replacement   = "/var/log/pods/*$1/*$2/*.log"
        }
      }

      // Scrape logs from discovered pods
      loki.source.kubernetes "pods" {
        targets    = discovery.relabel.pods.output
        forward_to = [loki.process.pods.receiver]
      }

      // Process logs (parse container runtime format)
      loki.process "pods" {
        forward_to = [loki.write.loki.receiver]

        stage.cri {}
      }

      // Write logs to Loki
      loki.write "loki" {
        endpoint {
          url = "http://loki-gateway.monitoring.svc.cluster.local/loki/api/v1/push"
        }
      }

# Deploy as DaemonSet (one pod per node)
controller:
  type: "daemonset"

# Resource limits
resources:
  requests:
    cpu: 50m
    memory: 64Mi
  limits:
    cpu: 200m
    memory: 128Mi

# Allow running on control plane nodes
tolerations:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
    operator: Exists
